# 控制语句与基本块

之前的几章中，我们反复提到WASM的局部变量机制与栈机、寄存器机的特性，其中我们指出，早期WASM的基本块语法设计导致局部变量的使用，但后来已经解决。在这一章里，我们将介绍在编程中不可或缺的元素——控制语句，并且用实际的例子，给大家分析基本块与寄存器机、栈机。

## 函数调用

首先，我们来讲讲函数调用，从某种意义上，它也是一种控制语句。在WASM中，我们可以使用`call`语句进行函数调用。它与我们在高级语言中常见的函数调用几乎没有区别，唯一要注意的就是对于栈的控制。举一个实际的例子，我们会更好理解：

```wasm
(module
    (func $foo (param i32 i32) (result i32 i32 i32)
        ;; Do something...
    )
    (func $bar
        i32.const 1
        i32.const 1
        call $foo
        ;; Here we got three elements on the stack
    )
)
```

我们定义了一个接受两个参数，返回三个值的函数`$foo`（函数返回多个值的提案[Multi-value proposal](https://github.com/WebAssembly/spec/blob/master/proposals/multi-value/Overview.md)已经成为标准化特性而被广泛实现了），当我们在函数`$bar`中调用`$foo`函数时，首先得确保栈上已经有两个元素了。在调用`$foo`之后，栈上的两个元素被这个函数消耗掉了（也就是弹栈走了），然后`$foo`返回了三个值，都存储在栈上，所以此时栈上有三个元素。

此外，值得一提，函数调用指令也适用我们之前提到的语法糖，也就是：

```wasm
(func $bar
    (call $foo (i32.const 1) (i32.const 1))
    ;; Here we got three elements on the stack
)
```

在了解了函数调用的栈性质之后，我们其实可以**模拟**出之前提到的peek和poke了：

```wasm
(module
    (func $peek0 (param i32) (result i32 i32)
        local.get 0
        local.get 0
    )

    (func $peek1 (param i32 i32) (result i32 i32 i32)
        local.get 0
        local.get 1
        local.get 0
    )
)
```

`$peek0`函数做的事是将距离栈顶0个元素（也就是栈顶元素）复制并压栈，而`peek1`则是将距离栈顶为1的元素复制并压栈。

## 选择语句

熟悉底层汇编的开发者一定了解，对于我们在高级语言中常见的选择语句`if`...`else`，在大部分的汇编架构中，其往往是实现成针对特定flag的标签跳转。但在WASM中，实际上提供了更高层面的抽象，也就是接近高级语言的`if`...`else`...`end`语句，即：

```wasm
if
    ;; True branch
else
    ;; False branch
end
```

在执行这个结构时，会从栈上将栈顶元素弹栈，若其为0，则执行False分支，否则执行True分支，非常符合直觉。

我们在高级语言中使用选择语句的时候，往往是通过比大小来判断执行哪个分支，其本质上就是将大小转变为布尔值，然后根据布尔值来做判断。在WASM中，也提供了一系列将大小转变为布尔值的指令，例如

```wasm
i32.const 1219
i32.const 323
i32.ge_u
```

上述程序将得到1。其意思是，`i32.ge_u`的`ge`代表大于等于（greater than or equal to），而`u`代表将两个操作数看做无符号整数（之前我们提过，WASM的整数的有无符号是根据指令来决定的）。类似地，我们一共有`ge`、`gt`、`lt`、`le`、`eq`、`ne`等大小比较，与`s`、`u`的组合。

在了解了函数调用与选择语句之后，我们就可以实现一个简单的递归形式的阶乘函数了：

```wasm
(func $factorial_recur (param $input i32) (result i32)
    (i32.le_u (local.get $input) (i32.const 1))
    if
        i32.const 1
        return
    end
    (i32.mul
        (local.get $input)
        (call $factorial_recur (i32.sub (local.get $input) (i32.const 1)))
    )
)
```

上述代码非常简洁清楚，如果不明白，我们可以用类似的C语言来帮助理解：

```c
unsigned int factorial_recur(unsigned int input) {
    if (input <= 1) {
        return 1;
    }
    return input * factorial_recur(input - 1);
}
```

## 基本块与跳转

除了选择语句以外，我们常见的循环语句，在底层往往需要通过跳转来实现。在WASN中，循环语句的跳转往往与基本块相绑定。

具体而言，WASM中的跳转包括`br`和`br_if`，前者相当于底层汇编指令中的无条件跳转，例如AMD64中的`jmp`，而`br_if`则是有条件跳转，其工作方式与WASM中的`if`类似，消耗掉栈顶的一个值，判断其是否为true，如果为true则跳转。这两者使用起来很类似，所以接下来就以`br_if`为例。

在WASM中，如果需要使用这类跳转，往往必须在一个基本块`block`或者`loop`中，具体而言，是这样的一个结构：

```wasm
(func
    ;; Do something
    (block $my_block
        ;; Do something inside this block
        br_if $my_block
        ;; Do something else
    )
    ;; ...
    (loop $my_loop
        ;; Do something inside this loop
        br_if $my_loop
        ;; Do something else
    )
)
```

我们通过`block`和`loop`可以附带一个标识符，然后在`br`或者`br_if`的指令中，操作数就是相应的标识符，也就是`br_if $my_block`和`br_if $my_loop`。

这两者有什么区别呢？很简单，`br`以及`br_if`，在`block`中将跳转到`block`之后的指令，而在`loop`中则会跳转到`loop`开头的第一条指令。我们可以近似地理解成，在`block`中充当了C语言中`break`的作用，而在`loop`中充当了C语言`continue`的作用。并且一点很重要的是，`block`和`loop`本身并不是循环，也就是说，它内部如果没有`br`或者`br_if`，则执行完这个基本块就不会重复执行，而是接下来执行下一条指令。

```wasm
(func (export "factorial_iter_stack") (param $input i32) (result i32)
    i32.const 1
    local.get $input
    loop $main_loop (param i32 i32) (result i32)
        call $peek1
        call $peek1
        i32.mul
        call $peek1
        i32.const 1
        i32.sub
        call $peek0
        i32.const 1
        i32.gt_u
        br_if $main_loop
        call $peek1
        return
    end
)
```

```plaintext
[i32.const 1]          1
[local.get $input]     1  3
[INSIDE $main_loop]    1  3
[call $peek1]          1  3  1
[call $peek1]          1  3  1  3
[i32.mul]              1  3  3
[call $peek1]          1  3  3  3
[i32.const 1]          1  3  3  3  1
[i32.sub]              1  3  3  2
[call $peek0]          1  3  3  2  2
[i32.const 1]          1  3  3  2  2  1
[i32.gt_u]             1  3  3  2  1
[br_if $main_loop YES] 3  2
[INSIDE $main_loop]    3  2
[call $peek1]          3  2  3
[call $peek1]          3  2  3  2
[i32.mul]              3  2  6
[call $peek1]          3  2  6  2
[i32.const 1]          3  2  6  2  1
[i32.sub]              3  2  6  1
[call $peek0]          3  2  6  1  1
[i32.const 1]          3  2  6  1  1  1
[i32.gt_u]             3  2  6  1  0
[br_if $main_loop NO]  3  2  6  1
[call $peek1]          3  2  6  1  6
[return]               6
```
