# 基本语法

在深入学习了如何生成与使用WASM程序之后，我们已经有了许多模板，比如Rust生成WASM的，比如Web使用WASM的。因此，接下来我们就可以完全关注在WASM代码本身，一切新学习到的知识都可以通过之前拥有的模板来验证、测试。

本章中，我们将学习WASM的基本语法。我们仍然以Hello world一章中最基本的程序`library.wat`为例：

```wasm
(module ;; Define a module
    ;; Define a function with name `add`, two parameters of type i32, and returns i32
    (func $add (param $left i32) (param $right i32) (result i32)
        local.get $left ;; Push parameter `left` to stack
        local.get $right ;; Push parameter `right` to stack
        i32.add ;; Consume two values at stack top, and push the sum to stack
    )
    (export "add" (func $add)) ;; Export this function with symbol "add"
)
```

## 注释

首先，我们第一眼看这个代码，就可以立刻明白，在WASM中，以两个分号`;;`打头的是注释。因此，在仔细研究其语法结构的时候，可以在脑中直接把注释部分忽略，也就是下面这个样子：

```wasm
(module
    (func $add (param $left i32) (param $right i32) (result i32)
        local.get $left
        local.get $right
        i32.add
    )
    (export "add" (func $add))
)
```

## S表达式

熟悉Lisp语言的开发者在看到WASM的文本格式代码时，肯定第一眼就会说，这不就是S表达式（S-Expression）嘛！没错，WASM的文本格式，其整体而言是以S表达式的形式组织的。

严格来说，一个S表达式的定义为：

* 一个原子元素，或
* `(x y)`，其中`x`和`y`都是S表达式

这种格式非常适合表示树结构，在编程语言中，非常常见的树结构就是抽象语法树。例如，在Lisp中：

```lisp
(* 5 (+ 7 3))
```

意思就是`5 * (7 + 3)`。通过S表达式，Lisp的代码可以轻松地解析为抽象语法树。

那我们就以S表达式的眼光，来看看我们的WASM代码的结构：

* 从最外层来看，是一个`module`，其有两个组件：一个`func`，一个`export`。
   * 对于`func`来说，其有三个子组件：两个`param`和一个`result`。其余部分均可以看做原子元素
   * 对于`export`来说，其有一个子组件`func`。

因此，从树结构的角度来理解的话，这段WASM代码，其最大深度为3，也就是可以看做这种形状：

```plaintext
module
|------func
|      |-------param
|      |-------param
|      |-------result
|
|------export
       |-------func
```

## 模块

在WASM代码的顶层，是`module`。WASM规定，一个WASM程序对应一个WASM模块。因此，在我们的WASM代码中，顶层永远是`module`，并且不允许出现多个`module`。

事实上，在我们之前通过Rust使用WASM的过程中，经常出现`Module`类型，对应一个WASM模块，这就是对应的其代码中的根结点`module`。

## 函数

接下来，我们就好好研究一下WASM的函数是怎么写的。在WASM中，一个模块中可以有任意多个函数，而下面我们研究研究之前代码里的函数

```wasm
(func $add (param $left i32) (param $right i32) (result i32)
    local.get $left
    local.get $right
    i32.add
)
```

### 标识符

首先，我们看到，紧跟在`func`后面的，是`$add`。在WASM中，以`$`打头的称为标识符，它和我们在高级编程语言里遇到的标识符有着同样的作用。也就是说，`func $add`就代表这个函数名字叫add。

有两点需要注意的。首先，标识符不是必须的。标识符的存在，只是为了方便后续对这个元素的引用。例如，我们可以看到，在我们的WASM代码中，最后的`export`一段，引用了我们之前定义的函数`func $add`。因此，我们才必须给这个函数一个名字`$add`。如果我们在整个代码中，不需要引用这个函数，那我们无需给这个函数名字，可以直接写成

```wasm
(func (param $left i32) (param $right i32) (result i32)
    local.get $left
    local.get $right
    i32.add
)
```

第二点，标识符不是必须出现在二进制格式中的。和高级编程语言一样，标识符只是方便开发者进行编程。而一个标识符究竟会不会出现在生成的二进制镜像中，这取决于开发者的意愿。如果我们想将这个标识符导出，那么这个标识符就可以以字符串的形式出现在二进制镜像中。我们WASM代码的最后一段的`export`就做了这个事。

### 签名

在`func $add`之后，是声明这个函数的参数、返回值类型。这里我们可以很直观地看到，这个函数接收两个`i32`类型的参数，返回一个`i32`类型的值。一个函数的参数+返回值类型，称为这个函数的签名（Signature）。

对于参数来说，正如我们之前提到的，如果一个参数不需要用名字去引用它，就可以省略相应的标识符，例如`(param i32)`。如果一个函数的参数都没有标识符，我们有一个语法糖：

```wasm
(func $add (param i32 i32) (result i32)
    ;; ...
)
```

此外，我们也可以额外加一个`type`语句，用来double check一下这个函数的签名的正确性：

```wasm
(module
    (type $add_type (func (param i32 i32) (result i32)))
    (func $add (type $add_type) (param $left i32) (param $right i32) (result i32)
        local.get $left
        local.get $right
        i32.add
    )
    (export "add" (func $add))
)
```

### 栈机

我们接下来就重点关注其函数体，也就是其中的指令部分：两个`local.get`和一个`i32.add`。

在了解具体指令之前，我们首先需要知道「栈机」（Stack machine）和「寄存器机」（Register machine）。

#### 计算模型

对于一个基于虚拟机的编程语言（例如Java基于JVM，Rust、C/C++可以基于WASM），所谓的「虚拟机」就是指，输入其自定义的指令字节码（如JVM字节码、WASM二进制表示等），虚拟机将根据指令字节码，执行相应的指令。在我们实现这样一个虚拟机的时候，往往需要设计一种「计算模型」（Computational model）。在虚拟机的常见实现中，主要分为两种计算模型：「栈机」和「寄存器机」。

例如，我们希望我们的虚拟机能够实现加法`add`指令：

* 对于栈机而言，我们需要在整个执行过程中，维护一个操作数栈。`add`指令不需要显式给出参数。我们若想执行加法功能，例如实现`2 + 3`，需要：

   1. 将数字2和3压入栈中
   2. 调用`add`指令
   3. 虚拟机从栈上弹出两个数字，也就是2和3
   4. 将其相加
   5. 把结果5压入栈中
* 对于寄存器机而言，我们需要维护一系列寄存器。`add`指令需要三个寄存器编号作为参数。我们若想执行`2 + 3`，需要：

   1. 先将2放入0号寄存器，然后将3放入1号寄存器，再将2号寄存器作为返回值存放的寄存器
   2. 将这3个寄存器编号，也就是0、1和2作为参数，调用`add`指令
   3. 虚拟机去相应的寄存器中寻找值
   4. 将其相加
   5. 把结果5存到2号寄存器中去

熟悉Intel的汇编以及调用约定的开发者想必会有一些共鸣，从某种意义上，32位x86的调用约定类似一种栈机（但其返回值不通过栈传递），而64位AMD64的调用约定类似一种寄存器机。

此外，还需要注意的是，这里讲的栈机中的栈，和我们真正编程过程中使用的，进程的栈并不是同一个东西。进程的栈在执行过程中，还要把什么返回地址、帧指针之类的全压到栈上去，是一种混合了「调用栈」与「操作数栈」的模型。而这里讲的栈机的栈，仅仅是用来传递参数和返回值的。

当然，还有一点值得指出。无论是栈机还是寄存器机，都只是一种「模型」。也就是说，通过这种模型，可以很好地定义其执行的方式、顺序，但真正的虚拟机实现里，是不一定需要维护一个真实的栈或者一系列寄存器的，可以通过优化去做更多的事。

#### WASM栈机

WASM大致是一个栈机（但实际上，WASM的局部变量机制导致它不是一个真正的栈机，详情可见[WebAssembly Is Not a Stack Machine](http://troubles.md/wasm-is-not-a-stack-machine/)），目前我们可以粗略地用栈机的眼光来理解WASM的函数。

回到我们之前的add函数。从栈机的角度来简单地解释一下这个函数的意思：

* `local.get $left`

   将第一个参数压栈
* `local.get $right`

   将第二个参数压栈
* `i32.add`

   从栈上弹出两个参数，将其求和，然后将结果压栈

我们之前声明了`add`函数，可以注意到，我们说了它有一个`i32`类型的返回值。然后在这个函数结束的时候，它的栈上正好还剩这一个结果。这个最终剩在栈上的值，就会成为这个函数的返回值。这种栈的「平衡性」，也是WASM引擎的「验证」阶段可以静态完成的一个重要的事。

此外，有一个非常重要的，值得注意的事：参数传递的顺序。我们可以发现，与x86不同，我们是**从左往右**压栈。也就是说，接下来的指令的第一个参数先压栈，最后一个参数最后再压栈。这是值得注意的。

另外，我们需要强调的是，尽管在上述指令的解释中，我们用了「压栈」，但实际上这些指令本身是不会压栈的，也没有一个指令专门是「压栈」。只不过是，WASM在执行每条指令时，将根据这条指令的特性，调整栈。例如，WASM在执行时，发现这条指令是`local.get`，它不接受参数，返回一个值，因此将这条执行执行后的值放到栈上；在执行到`i32.add`时，发现这条指令接受两个参数，返回一个值，因此把栈上弹两个值出来，作为参数，执行后把结果存到栈上。

在真正书写WASM的过程中，我们有一个语法糖（一般被称为折叠格式（folded form））：

```wasm
(func $add (param $left i32) (param $right i32) (result i32)
    (i32.add (local.get $left) (local.get $right))
)
```

这个语法一看就和我们正常的高级语言的语法类似了，但是这是个语法糖，其底层还是会变成之前的栈机形式，不过这种写法更利于人类阅读和书写。

## 指令

在WASM中，大部分的指令都分为两个部分，前半部分表示指令所属的类别，后半部分表示指令的内容。例如，之前我们遇到的`local.get`，其类别属于`local`，内容是获取local的值；`i32.add`，类别属于`i32`，内容是将两个i32的值相加。

WASM的指令数目不多，和AArch64类似，基本属于精简指令集了，不会有非常复杂的指令。具体的指令列表可以参考官方文档[Index of Instructions](https://webassembly.github.io/spec/core/appendix/index-instructions.html)。在本系列中，不会集中地讲解指令集，而是会在需要的地方，详细解释与某些概念息息相关的指令。

## 导出

在最后，我们使用了

```wasm
(export "add" (func $add))
```

来表示，我们要导出之前声明的一个叫`$add`的函数，并且它的导出的名字是"add"。事实上，还有一种更简单的写法：

```wasm
(module
    (func (export "add") (param $left i32) (param $right i32) (result i32)
        local.get $left
        local.get $right
        i32.add
    )
)
```

将最后一个export语句直接移到函数的定义中。这样的话，就不需要在后面引用这个函数，从而不需要再给这个函数命名了，所以我们自然也省去了`$add`这个标识符。
